{"version":3,"file":"app.js","sources":["domReady.js","raven.js","modules/monitor.js"],"names":["name","definition","module","exports","define","amd","this","listener","fns","doc","document","hack","documentElement","doScroll","domContentLoaded","loaded","test","readyState","addEventListener","removeEventListener","shift","fn","push","window","undefined","triggerEvent","eventType","options","event","key","substr","toUpperCase","createEvent","initEvent","createEventObject","hasKey","dispatchEvent","fireEvent","toLowerCase","e","RavenConfigError","message","parseDSN","str","m","dsnPattern","exec","dsn","i","dsnKeys","pass","isUndefined","what","isFunction","isString","isObject","isEmptyObject","k","isError","objectPrototype","toString","call","Error","object","hasOwnProperty","each","obj","callback","j","length","setAuthQueryString","authQueryString","Raven","VERSION","globalKey","handleStackInfo","stackInfo","frames","stack","frame","normalizeFrame","processException","url","lineno","normalized","filename","line","colno","column","function","func","context","extractContextFromFrame","keys","in_app","globalOptions","includePaths","fetchContext","pivot","isMinified","slice","type","fileurl","stacktrace","label","ignoreErrors","reverse","truncate","maxMessageLength","ignoreUrls","whitelistUrls","send","objectMerge","exception","value","culprit","obj1","obj2","max","now","Date","getHttpData","http","location","href","headers","User-Agent","navigator","userAgent","referrer","Referer","data","isSetup","project","globalProject","logger","platform","request","tags","extra","session:duration","startTime","globalUser","user","release","dataCallback","shouldSendCallback","lastEventId","event_id","uuid4","makeRequest","img","Image","src","globalServer","encodeURIComponent","JSON","stringify","crossOrigin","onload","onerror","onabort","hasJSON","logDebug","joinRegExp","patterns","pattern","sources","len","replace","source","RegExp","join","c","r","Math","random","v","level","console","debug","afterLoad","RavenConfig","config","install","TraceKit","remoteFetching","collectWindowErrors","linesOfContext","_slice","UNKNOWN_FUNCTION","wrap","wrapped","apply","arguments","report","subscribe","handler","installGlobalHandler","handlers","unsubscribe","splice","unsubscribeAll","uninstallGlobalHandler","notifyHandlers","isWindowError","concat","inner","traceKitWindowOnError","lineNo","colNo","ex","lastExceptionStack","computeStackTrace","augmentStackTraceWithInitialElement","processLastException","guessFunctionName","gatherContext","_oldOnerrorHandler","_onErrorHandlerInstalled","_lastExceptionStack","_lastArgs","lastArgs","lastException","rethrow","args","setTimeout","incomplete","uninstall","loadSource","getXHR","XMLHttpRequest","ActiveXObject","open","responseText","getSource","sourceCache","indexOf","domain","split","reFunctionArgNames","reGuessFunction","maxLines","linesBefore","floor","linesAfter","start","end","min","escapeRegExp","text","escapeCodeAsRegExpForMatchingInsideHTML","body","findSourceInUrls","re","urls","substring","index","lastIndexOf","findSourceInLine","fragment","findSourceByFunctionBody","parts","result","scripts","getElementsByTagName","code","codeRE","eventRE","script","computeStackTraceFromStackProp","element","chrome","gecko","lines","reference","columnNumber","computeStackTraceFromStacktraceProp","testRE","exc","computeStackTraceFromOperaMultiLineMessage","lineRE1","lineRE2","lineRE3","inlineScriptBlocks","item","relativeLine","pos","innerText","midline","initial","unshift","partial","computeStackTraceByWalkingCallerChain","depth","functionName","funcs","recursion","curr","caller","description","sourceURL","fileName","lineNumber","lastCapturedException","_Raven","isRavenInstalled","Object","prototype","noConflict","uri","lastSlash","path","host","port","protocol","deep","captureException","__raven__","property","__inner__","captureMessage","ex1","msg","setUserContext","setExtraContext","setTagsContext","setReleaseContext","setUser","constructor","git_commit","GRUNT_SENTRY_DSN","GRUNT_LAST_GIT_COMMIT","modules","extractTags","bodyClass","getAttribute","itemTone","match","itemId","deviceKind","ads","ignoreArray","setContext","init","sampleRate","raven","gu","getElementById","baseUrl","require","paths","bonzo","bean","d3","domReady","mobileSlider","fastClick","qwery","fence","smoothScroll","shim","monitor","loadCss","basePath","link","createElement","rel","appendChild","contentType","Article","Liveblog","Audio","Gallery","Football","Common","scriptTag","skipStyle"],"mappings":"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","sourcesContent":["/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */\n!function (name, definition) {\n\n  if (typeof module != 'undefined') module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define('domReady',definition)\n  else this[name] = definition()\n\n}('domready', function () {\n\n  var fns = [], listener\n    , doc = document\n    , hack = doc.documentElement.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)\n\n\n  if (!loaded)\n  doc.addEventListener(domContentLoaded, listener = function () {\n    doc.removeEventListener(domContentLoaded, listener)\n    loaded = 1\n    while (listener = fns.shift()) listener()\n  })\n\n  return function (fn) {\n    loaded ? fn() : fns.push(fn)\n  }\n\n});\n\n","/*! Raven.js 1.1.18 (8ad15bc) | github.com/getsentry/raven-js */\n\n/*\n * Includes TraceKit\n * https://github.com/getsentry/TraceKit\n *\n * Copyright 2015 Matt Robenolt and other contributors\n * Released under the BSD license\n * https://github.com/getsentry/raven-js/blob/master/LICENSE\n *\n */\n;(function(window, undefined){\n'use strict';\n\n/*\n TraceKit - Cross brower stack traces - github.com/occ/TraceKit\n MIT license\n*/\n\nvar TraceKit = {\n    remoteFetching: false,\n    collectWindowErrors: true,\n    // 3 lines before, the offending line, 3 lines after\n    linesOfContext: 7\n};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n\n/**\n * TraceKit.wrap: Wrap any function in a TraceKit reporter\n * Example: func = TraceKit.wrap(func);\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n */\nTraceKit.wrap = function traceKitWrapper(func) {\n    function wrapped() {\n        try {\n            return func.apply(this, arguments);\n        } catch (e) {\n            TraceKit.report(e);\n            throw e;\n        }\n    }\n    return wrapped;\n};\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = (function reportModuleWrapper() {\n    var handlers = [],\n        lastArgs = null,\n        lastException = null,\n        lastExceptionStack = null;\n\n    /**\n     * Add a crash handler.\n     * @param {Function} handler\n     */\n    function subscribe(handler) {\n        installGlobalHandler();\n        handlers.push(handler);\n    }\n\n    /**\n     * Remove a crash handler.\n     * @param {Function} handler\n     */\n    function unsubscribe(handler) {\n        for (var i = handlers.length - 1; i >= 0; --i) {\n            if (handlers[i] === handler) {\n                handlers.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * Remove all crash handlers.\n     */\n    function unsubscribeAll() {\n        uninstallGlobalHandler();\n        handlers = [];\n    }\n\n    /**\n     * Dispatch stack information to all handlers.\n     * @param {Object.<string, *>} stack\n     */\n    function notifyHandlers(stack, isWindowError) {\n        var exception = null;\n        if (isWindowError && !TraceKit.collectWindowErrors) {\n          return;\n        }\n        for (var i in handlers) {\n            if (hasKey(handlers, i)) {\n                try {\n                    handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n                } catch (inner) {\n                    exception = inner;\n                }\n            }\n        }\n\n        if (exception) {\n            throw exception;\n        }\n    }\n\n    var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n    /**\n     * Ensures all global unhandled exceptions are recorded.\n     * Supported by Gecko and IE.\n     * @param {string} message Error message.\n     * @param {string} url URL of script that generated the exception.\n     * @param {(number|string)} lineNo The line number at which the error\n     * occurred.\n     * @param {?(number|string)} colNo The column number at which the error\n     * occurred.\n     * @param {?Error} ex The actual Error object.\n     */\n    function traceKitWindowOnError(message, url, lineNo, colNo, ex) {\n        var stack = null;\n\n        if (lastExceptionStack) {\n            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n            processLastException();\n        } else if (ex) {\n            // New chrome and blink send along a real error object\n            // Let's just report that like a normal error.\n            // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n            stack = TraceKit.computeStackTrace(ex);\n            notifyHandlers(stack, true);\n        } else {\n            var location = {\n                'url': url,\n                'line': lineNo,\n                'column': colNo\n            };\n            location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);\n            location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);\n            stack = {\n                'message': message,\n                'url': document.location.href,\n                'stack': [location]\n            };\n            notifyHandlers(stack, true);\n        }\n\n        if (_oldOnerrorHandler) {\n            return _oldOnerrorHandler.apply(this, arguments);\n        }\n\n        return false;\n    }\n\n    function installGlobalHandler ()\n    {\n        if (_onErrorHandlerInstalled) {\n            return;\n        }\n        _oldOnerrorHandler = window.onerror;\n        window.onerror = traceKitWindowOnError;\n        _onErrorHandlerInstalled = true;\n    }\n\n    function uninstallGlobalHandler ()\n    {\n        if (!_onErrorHandlerInstalled) {\n            return;\n        }\n        window.onerror = _oldOnerrorHandler;\n        _onErrorHandlerInstalled = false;\n        _oldOnerrorHandler = undefined;\n    }\n\n    function processLastException() {\n        var _lastExceptionStack = lastExceptionStack,\n            _lastArgs = lastArgs;\n        lastArgs = null;\n        lastExceptionStack = null;\n        lastException = null;\n        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n    }\n\n    /**\n     * Reports an unhandled Error to TraceKit.\n     * @param {Error} ex\n     * @param {?boolean} rethrow If false, do not re-throw the exception.\n     * Only used for window.onerror to not cause an infinite loop of\n     * rethrowing.\n     */\n    function report(ex, rethrow) {\n        var args = _slice.call(arguments, 1);\n        if (lastExceptionStack) {\n            if (lastException === ex) {\n                return; // already caught by an inner catch block, ignore\n            } else {\n              processLastException();\n            }\n        }\n\n        var stack = TraceKit.computeStackTrace(ex);\n        lastExceptionStack = stack;\n        lastException = ex;\n        lastArgs = args;\n\n        // If the stack trace is incomplete, wait for 2 seconds for\n        // slow slow IE to see if onerror occurs or not before reporting\n        // this exception; otherwise, we will end up with an incomplete\n        // stack trace\n        window.setTimeout(function () {\n            if (lastException === ex) {\n                processLastException();\n            }\n        }, (stack.incomplete ? 2000 : 0));\n\n        if (rethrow !== false) {\n            throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n        }\n    }\n\n    report.subscribe = subscribe;\n    report.unsubscribe = unsubscribe;\n    report.uninstall = unsubscribeAll;\n    return report;\n}());\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n    var debug = false,\n        sourceCache = {};\n\n    /**\n     * Attempts to retrieve source code via XMLHttpRequest, which is used\n     * to look up anonymous function names.\n     * @param {string} url URL of source code.\n     * @return {string} Source contents.\n     */\n    function loadSource(url) {\n        if (!TraceKit.remoteFetching) { //Only attempt request if remoteFetching is on.\n            return '';\n        }\n        try {\n            var getXHR = function() {\n                try {\n                    return new window.XMLHttpRequest();\n                } catch (e) {\n                    // explicitly bubble up the exception if not found\n                    return new window.ActiveXObject('Microsoft.XMLHTTP');\n                }\n            };\n\n            var request = getXHR();\n            request.open('GET', url, false);\n            request.send('');\n            return request.responseText;\n        } catch (e) {\n            return '';\n        }\n    }\n\n    /**\n     * Retrieves source code from the source code cache.\n     * @param {string} url URL of source code.\n     * @return {Array.<string>} Source contents.\n     */\n    function getSource(url) {\n        if (!isString(url)) return [];\n        if (!hasKey(sourceCache, url)) {\n            // URL needs to be able to fetched within the acceptable domain.  Otherwise,\n            // cross-domain errors will be triggered.\n            var source = '';\n            if (url.indexOf(document.domain) !== -1) {\n                source = loadSource(url);\n            }\n            sourceCache[url] = source ? source.split('\\n') : [];\n        }\n\n        return sourceCache[url];\n    }\n\n    /**\n     * Tries to use an externally loaded copy of source code to determine\n     * the name of a function by looking at the name of the variable it was\n     * assigned to, if any.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} lineNo Line number in source code.\n     * @return {string} The function name, if discoverable.\n     */\n    function guessFunctionName(url, lineNo) {\n        var reFunctionArgNames = /function ([^(]*)\\(([^)]*)\\)/,\n            reGuessFunction = /['\"]?([0-9A-Za-z$_]+)['\"]?\\s*[:=]\\s*(function|eval|new Function)/,\n            line = '',\n            maxLines = 10,\n            source = getSource(url),\n            m;\n\n        if (!source.length) {\n            return UNKNOWN_FUNCTION;\n        }\n\n        // Walk backwards from the first line in the function until we find the line which\n        // matches the pattern above, which is the function definition\n        for (var i = 0; i < maxLines; ++i) {\n            line = source[lineNo - i] + line;\n\n            if (!isUndefined(line)) {\n                if ((m = reGuessFunction.exec(line))) {\n                    return m[1];\n                } else if ((m = reFunctionArgNames.exec(line))) {\n                    return m[1];\n                }\n            }\n        }\n\n        return UNKNOWN_FUNCTION;\n    }\n\n    /**\n     * Retrieves the surrounding lines from where an exception occurred.\n     * @param {string} url URL of source code.\n     * @param {(string|number)} line Line number in source code to centre\n     * around for context.\n     * @return {?Array.<string>} Lines of source code.\n     */\n    function gatherContext(url, line) {\n        var source = getSource(url);\n\n        if (!source.length) {\n            return null;\n        }\n\n        var context = [],\n            // linesBefore & linesAfter are inclusive with the offending line.\n            // if linesOfContext is even, there will be one extra line\n            //   *before* the offending line.\n            linesBefore = Math.floor(TraceKit.linesOfContext / 2),\n            // Add one extra line if linesOfContext is odd\n            linesAfter = linesBefore + (TraceKit.linesOfContext % 2),\n            start = Math.max(0, line - linesBefore - 1),\n            end = Math.min(source.length, line + linesAfter - 1);\n\n        line -= 1; // convert to 0-based index\n\n        for (var i = start; i < end; ++i) {\n            if (!isUndefined(source[i])) {\n                context.push(source[i]);\n            }\n        }\n\n        return context.length > 0 ? context : null;\n    }\n\n    /**\n     * Escapes special characters, except for whitespace, in a string to be\n     * used inside a regular expression as a string literal.\n     * @param {string} text The string.\n     * @return {string} The escaped string literal.\n     */\n    function escapeRegExp(text) {\n        return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n    }\n\n    /**\n     * Escapes special characters in a string to be used inside a regular\n     * expression as a string literal. Also ensures that HTML entities will\n     * be matched the same as their literal friends.\n     * @param {string} body The string.\n     * @return {string} The escaped string.\n     */\n    function escapeCodeAsRegExpForMatchingInsideHTML(body) {\n        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n    }\n\n    /**\n     * Determines where a code fragment occurs in the source code.\n     * @param {RegExp} re The function definition.\n     * @param {Array.<string>} urls A list of URLs to search.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     */\n    function findSourceInUrls(re, urls) {\n        var source, m;\n        for (var i = 0, j = urls.length; i < j; ++i) {\n            // console.log('searching', urls[i]);\n            if ((source = getSource(urls[i])).length) {\n                source = source.join('\\n');\n                if ((m = re.exec(source))) {\n                    // console.log('Found function in ' + urls[i]);\n\n                    return {\n                        'url': urls[i],\n                        'line': source.substring(0, m.index).split('\\n').length,\n                        'column': m.index - source.lastIndexOf('\\n', m.index) - 1\n                    };\n                }\n            }\n        }\n\n        // console.log('no match');\n\n        return null;\n    }\n\n    /**\n     * Determines at which column a code fragment occurs on a line of the\n     * source code.\n     * @param {string} fragment The code fragment.\n     * @param {string} url The URL to search.\n     * @param {(string|number)} line The line number to examine.\n     * @return {?number} The column number.\n     */\n    function findSourceInLine(fragment, url, line) {\n        var source = getSource(url),\n            re = new RegExp('\\\\b' + escapeRegExp(fragment) + '\\\\b'),\n            m;\n\n        line -= 1;\n\n        if (source && source.length > line && (m = re.exec(source[line]))) {\n            return m.index;\n        }\n\n        return null;\n    }\n\n    /**\n     * Determines where a function was defined within the source code.\n     * @param {(Function|string)} func A function reference or serialized\n     * function definition.\n     * @return {?Object.<string, (string|number)>} An object containing\n     * the url, line, and column number of the defined function.\n     */\n    function findSourceByFunctionBody(func) {\n        var urls = [window.location.href],\n            scripts = document.getElementsByTagName('script'),\n            body,\n            code = '' + func,\n            codeRE = /^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            eventRE = /^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n            re,\n            parts,\n            result;\n\n        for (var i = 0; i < scripts.length; ++i) {\n            var script = scripts[i];\n            if (script.src) {\n                urls.push(script.src);\n            }\n        }\n\n        if (!(parts = codeRE.exec(code))) {\n            re = new RegExp(escapeRegExp(code).replace(/\\s+/g, '\\\\s+'));\n        }\n\n        // not sure if this is really necessary, but I don’t have a test\n        // corpus large enough to confirm that and it was in the original.\n        else {\n            var name = parts[1] ? '\\\\s+' + parts[1] : '',\n                args = parts[2].split(',').join('\\\\s*,\\\\s*');\n\n            body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\\s+/g, '\\\\s+');\n            re = new RegExp('function' + name + '\\\\s*\\\\(\\\\s*' + args + '\\\\s*\\\\)\\\\s*{\\\\s*' + body + '\\\\s*}');\n        }\n\n        // look for a normal function definition\n        if ((result = findSourceInUrls(re, urls))) {\n            return result;\n        }\n\n        // look for an old-school event handler function\n        if ((parts = eventRE.exec(code))) {\n            var event = parts[1];\n            body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);\n\n            // look for a function defined in HTML as an onXXX handler\n            re = new RegExp('on' + event + '=[\\\\\\'\"]\\\\s*' + body + '\\\\s*[\\\\\\'\"]', 'i');\n\n            if ((result = findSourceInUrls(re, urls[0]))) {\n                return result;\n            }\n\n            // look for ???\n            re = new RegExp(body);\n\n            if ((result = findSourceInUrls(re, urls))) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    // Contents of Exception in various browsers.\n    //\n    // SAFARI:\n    // ex.message = Can't find variable: qq\n    // ex.line = 59\n    // ex.sourceId = 580238192\n    // ex.sourceURL = http://...\n    // ex.expressionBeginOffset = 96\n    // ex.expressionCaretOffset = 98\n    // ex.expressionEndOffset = 98\n    // ex.name = ReferenceError\n    //\n    // FIREFOX:\n    // ex.message = qq is not defined\n    // ex.fileName = http://...\n    // ex.lineNumber = 59\n    // ex.columnNumber = 69\n    // ex.stack = ...stack trace... (see the example below)\n    // ex.name = ReferenceError\n    //\n    // CHROME:\n    // ex.message = qq is not defined\n    // ex.name = ReferenceError\n    // ex.type = not_defined\n    // ex.arguments = ['aa']\n    // ex.stack = ...stack trace...\n    //\n    // INTERNET EXPLORER:\n    // ex.message = ...\n    // ex.name = ReferenceError\n    //\n    // OPERA:\n    // ex.message = ...message... (see the example below)\n    // ex.name = ReferenceError\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n    /**\n     * Computes stack trace information from the stack property.\n     * Chrome and Gecko use this property.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack trace information.\n     */\n    function computeStackTraceFromStackProp(ex) {\n        if (!ex.stack) {\n            return null;\n        }\n\n        var chrome = /^\\s*at (.*?) ?\\(?((?:file|https?|chrome-extension):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n            gecko = /^\\s*(.*?)(?:\\((.*?)\\))?@((?:file|https?|chrome).*?):(\\d+)(?::(\\d+))?\\s*$/i,\n            lines = ex.stack.split('\\n'),\n            stack = [],\n            parts,\n            element,\n            reference = /^(.*) is undefined$/.exec(ex.message);\n\n        for (var i = 0, j = lines.length; i < j; ++i) {\n            if ((parts = gecko.exec(lines[i]))) {\n                element = {\n                    'url': parts[3],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': parts[2] ? parts[2].split(',') : '',\n                    'line': +parts[4],\n                    'column': parts[5] ? +parts[5] : null\n                };\n            } else if ((parts = chrome.exec(lines[i]))) {\n                element = {\n                    'url': parts[2],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'line': +parts[3],\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else {\n                continue;\n            }\n\n            if (!element.func && element.line) {\n                element.func = guessFunctionName(element.url, element.line);\n            }\n\n            if (element.line) {\n                element.context = gatherContext(element.url, element.line);\n            }\n\n            stack.push(element);\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        if (stack[0].line && !stack[0].column && reference) {\n            stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);\n        } else if (!stack[0].column && !isUndefined(ex.columnNumber)) {\n            // FireFox uses this awesome columnNumber property for its top frame\n            // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n            // so adding 1\n            stack[0].column = ex.columnNumber + 1;\n        }\n\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'url': document.location.href,\n            'stack': stack\n        };\n    }\n\n    /**\n     * Computes stack trace information from the stacktrace property.\n     * Opera 10 uses this property.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack trace information.\n     */\n    function computeStackTraceFromStacktraceProp(ex) {\n        // Access and store the stacktrace property before doing ANYTHING\n        // else to it because Opera is not very good at providing it\n        // reliably in other circumstances.\n        var stacktrace = ex.stacktrace;\n\n        var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\) in (.*):\\s*$/i,\n            lines = stacktrace.split('\\n'),\n            stack = [],\n            parts;\n\n        for (var i = 0, j = lines.length; i < j; i += 2) {\n            if ((parts = testRE.exec(lines[i]))) {\n                var element = {\n                    'line': +parts[1],\n                    'column': +parts[2],\n                    'func': parts[3] || parts[4],\n                    'args': parts[5] ? parts[5].split(',') : [],\n                    'url': parts[6]\n                };\n\n                if (!element.func && element.line) {\n                    element.func = guessFunctionName(element.url, element.line);\n                }\n                if (element.line) {\n                    try {\n                        element.context = gatherContext(element.url, element.line);\n                    } catch (exc) {}\n                }\n\n                if (!element.context) {\n                    element.context = [lines[i + 1]];\n                }\n\n                stack.push(element);\n            }\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'url': document.location.href,\n            'stack': stack\n        };\n    }\n\n    /**\n     * NOT TESTED.\n     * Computes stack trace information from an error message that includes\n     * the stack trace.\n     * Opera 9 and earlier use this method if the option to show stack\n     * traces is turned on in opera:config.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack information.\n     */\n    function computeStackTraceFromOperaMultiLineMessage(ex) {\n        // Opera includes a stack trace into the exception message. An example is:\n        //\n        // Statement on line 3: Undefined variable: undefinedFunc\n        // Backtrace:\n        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n        //         undefinedFunc(a);\n        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n        //           zzz(x, y, z);\n        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n        //           yyy(a, a, a);\n        //   Line 1 of function script\n        //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n        //   ...\n\n        var lines = ex.message.split('\\n');\n        if (lines.length < 4) {\n            return null;\n        }\n\n        var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?)\\S+)(?:: in function (\\S+))?\\s*$/i,\n            lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\n            stack = [],\n            scripts = document.getElementsByTagName('script'),\n            inlineScriptBlocks = [],\n            parts,\n            i,\n            len,\n            source;\n\n        for (i in scripts) {\n            if (hasKey(scripts, i) && !scripts[i].src) {\n                inlineScriptBlocks.push(scripts[i]);\n            }\n        }\n\n        for (i = 2, len = lines.length; i < len; i += 2) {\n            var item = null;\n            if ((parts = lineRE1.exec(lines[i]))) {\n                item = {\n                    'url': parts[2],\n                    'func': parts[3],\n                    'line': +parts[1]\n                };\n            } else if ((parts = lineRE2.exec(lines[i]))) {\n                item = {\n                    'url': parts[3],\n                    'func': parts[4]\n                };\n                var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\n                var script = inlineScriptBlocks[parts[2] - 1];\n                if (script) {\n                    source = getSource(item.url);\n                    if (source) {\n                        source = source.join('\\n');\n                        var pos = source.indexOf(script.innerText);\n                        if (pos >= 0) {\n                            item.line = relativeLine + source.substring(0, pos).split('\\n').length;\n                        }\n                    }\n                }\n            } else if ((parts = lineRE3.exec(lines[i]))) {\n                var url = window.location.href.replace(/#.*$/, ''),\n                    line = parts[1];\n                var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[i + 1]));\n                source = findSourceInUrls(re, [url]);\n                item = {\n                    'url': url,\n                    'line': source ? source.line : line,\n                    'func': ''\n                };\n            }\n\n            if (item) {\n                if (!item.func) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n                var context = gatherContext(item.url, item.line);\n                var midline = (context ? context[Math.floor(context.length / 2)] : null);\n                if (context && midline.replace(/^\\s*/, '') === lines[i + 1].replace(/^\\s*/, '')) {\n                    item.context = context;\n                } else {\n                    // if (context) alert(\"Context mismatch. Correct midline:\\n\" + lines[i+1] + \"\\n\\nMidline:\\n\" + midline + \"\\n\\nContext:\\n\" + context.join(\"\\n\") + \"\\n\\nURL:\\n\" + item.url);\n                    item.context = [lines[i + 1]];\n                }\n                stack.push(item);\n            }\n        }\n        if (!stack.length) {\n            return null; // could not parse multiline exception message as Opera stack trace\n        }\n\n        return {\n            'name': ex.name,\n            'message': lines[0],\n            'url': document.location.href,\n            'stack': stack\n        };\n    }\n\n    /**\n     * Adds information about the first frame to incomplete stack traces.\n     * Safari and IE require this to get complete data on the first frame.\n     * @param {Object.<string, *>} stackInfo Stack trace information from\n     * one of the compute* methods.\n     * @param {string} url The URL of the script that caused an error.\n     * @param {(number|string)} lineNo The line number of the script that\n     * caused an error.\n     * @param {string=} message The error generated by the browser, which\n     * hopefully contains the name of the object that caused the error.\n     * @return {boolean} Whether or not the stack information was\n     * augmented.\n     */\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n        var initial = {\n            'url': url,\n            'line': lineNo\n        };\n\n        if (initial.url && initial.line) {\n            stackInfo.incomplete = false;\n\n            if (!initial.func) {\n                initial.func = guessFunctionName(initial.url, initial.line);\n            }\n\n            if (!initial.context) {\n                initial.context = gatherContext(initial.url, initial.line);\n            }\n\n            var reference = / '([^']+)' /.exec(message);\n            if (reference) {\n                initial.column = findSourceInLine(reference[1], initial.url, initial.line);\n            }\n\n            if (stackInfo.stack.length > 0) {\n                if (stackInfo.stack[0].url === initial.url) {\n                    if (stackInfo.stack[0].line === initial.line) {\n                        return false; // already in stack trace\n                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n                        stackInfo.stack[0].line = initial.line;\n                        stackInfo.stack[0].context = initial.context;\n                        return false;\n                    }\n                }\n            }\n\n            stackInfo.stack.unshift(initial);\n            stackInfo.partial = true;\n            return true;\n        } else {\n            stackInfo.incomplete = true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Computes stack trace information by walking the arguments.caller\n     * chain at the time the exception occurred. This will cause earlier\n     * frames to be missed but is the only way to get any stack trace in\n     * Safari and IE. The top frame is restored by\n     * {@link augmentStackTraceWithInitialElement}.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack trace information.\n     */\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n            stack = [],\n            funcs = {},\n            recursion = false,\n            parts,\n            item,\n            source;\n\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n            if (curr === computeStackTrace || curr === TraceKit.report) {\n                // console.log('skipping internal function');\n                continue;\n            }\n\n            item = {\n                'url': null,\n                'func': UNKNOWN_FUNCTION,\n                'line': null,\n                'column': null\n            };\n\n            if (curr.name) {\n                item.func = curr.name;\n            } else if ((parts = functionName.exec(curr.toString()))) {\n                item.func = parts[1];\n            }\n\n            if ((source = findSourceByFunctionBody(curr))) {\n                item.url = source.url;\n                item.line = source.line;\n\n                if (item.func === UNKNOWN_FUNCTION) {\n                    item.func = guessFunctionName(item.url, item.line);\n                }\n\n                var reference = / '([^']+)' /.exec(ex.message || ex.description);\n                if (reference) {\n                    item.column = findSourceInLine(reference[1], source.url, source.line);\n                }\n            }\n\n            if (funcs['' + curr]) {\n                recursion = true;\n            }else{\n                funcs['' + curr] = true;\n            }\n\n            stack.push(item);\n        }\n\n        if (depth) {\n            // console.log('depth is ' + depth);\n            // console.log('stack is ' + stack.length);\n            stack.splice(0, depth);\n        }\n\n        var result = {\n            'name': ex.name,\n            'message': ex.message,\n            'url': document.location.href,\n            'stack': stack\n        };\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n        return result;\n    }\n\n    /**\n     * Computes a stack trace for an exception.\n     * @param {Error} ex\n     * @param {(string|number)=} depth\n     */\n    function computeStackTrace(ex, depth) {\n        var stack = null;\n        depth = (depth == null ? 0 : +depth);\n\n        try {\n            // This must be tried first because Opera 10 *destroys*\n            // its stacktrace property if you try to access the stack\n            // property first!!\n            stack = computeStackTraceFromStacktraceProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromStackProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceFromOperaMultiLineMessage(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n\n        return {};\n    }\n\n    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n    computeStackTrace.guessFunctionName = guessFunctionName;\n    computeStackTrace.gatherContext = gatherContext;\n\n    return computeStackTrace;\n}());\n\n'use strict';\n\n// First, check for JSON support\n// If there is no JSON, we no-op the core features of Raven\n// since JSON is required to encode the payload\nvar _Raven = window.Raven,\n    hasJSON = !!(typeof JSON === 'object' && JSON.stringify),\n    lastCapturedException,\n    lastEventId,\n    globalServer,\n    globalUser,\n    globalKey,\n    globalProject,\n    globalOptions = {\n        logger: 'javascript',\n        ignoreErrors: [],\n        ignoreUrls: [],\n        whitelistUrls: [],\n        includePaths: [],\n        collectWindowErrors: true,\n        tags: {},\n        maxMessageLength: 100,\n        extra: {}\n    },\n    authQueryString,\n    isRavenInstalled = false,\n\n    objectPrototype = Object.prototype,\n    startTime = now();\n\n/*\n * The core Raven singleton\n *\n * @this {Raven}\n */\nvar Raven = {\n    VERSION: '1.1.18',\n\n    debug: true,\n\n    /*\n     * Allow multiple versions of Raven to be installed.\n     * Strip Raven from the global context and returns the instance.\n     *\n     * @return {Raven}\n     */\n    noConflict: function() {\n        window.Raven = _Raven;\n        return Raven;\n    },\n\n    /*\n     * Configure Raven with a DSN and extra options\n     *\n     * @param {string} dsn The public Sentry DSN\n     * @param {object} options Optional set of of global options [optional]\n     * @return {Raven}\n     */\n    config: function(dsn, options) {\n        if (globalServer) {\n            logDebug('error', 'Error: Raven has already been configured');\n            return Raven;\n        }\n        if (!dsn) return Raven;\n\n        var uri = parseDSN(dsn),\n            lastSlash = uri.path.lastIndexOf('/'),\n            path = uri.path.substr(1, lastSlash);\n\n        // merge in options\n        if (options) {\n            each(options, function(key, value){\n                globalOptions[key] = value;\n            });\n        }\n\n        // \"Script error.\" is hard coded into browsers for errors that it can't read.\n        // this is the result of a script being pulled in from an external domain and CORS.\n        globalOptions.ignoreErrors.push(/^Script error\\.?$/);\n        globalOptions.ignoreErrors.push(/^Javascript error: Script error\\.? on line 0$/);\n\n        // join regexp rules into one big rule\n        globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);\n        globalOptions.ignoreUrls = globalOptions.ignoreUrls.length ? joinRegExp(globalOptions.ignoreUrls) : false;\n        globalOptions.whitelistUrls = globalOptions.whitelistUrls.length ? joinRegExp(globalOptions.whitelistUrls) : false;\n        globalOptions.includePaths = joinRegExp(globalOptions.includePaths);\n\n        globalKey = uri.user;\n        globalProject = uri.path.substr(lastSlash + 1);\n\n        // assemble the endpoint from the uri pieces\n        globalServer = '//' + uri.host +\n                      (uri.port ? ':' + uri.port : '') +\n                      '/' + path + 'api/' + globalProject + '/store/';\n\n        if (uri.protocol) {\n            globalServer = uri.protocol + ':' + globalServer;\n        }\n\n        if (globalOptions.fetchContext) {\n            TraceKit.remoteFetching = true;\n        }\n\n        if (globalOptions.linesOfContext) {\n            TraceKit.linesOfContext = globalOptions.linesOfContext;\n        }\n\n        TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;\n\n        setAuthQueryString();\n\n        // return for chaining\n        return Raven;\n    },\n\n    /*\n     * Installs a global window.onerror error handler\n     * to capture and report uncaught exceptions.\n     * At this point, install() is required to be called due\n     * to the way TraceKit is set up.\n     *\n     * @return {Raven}\n     */\n    install: function() {\n        if (isSetup() && !isRavenInstalled) {\n            TraceKit.report.subscribe(handleStackInfo);\n            isRavenInstalled = true;\n        }\n\n        return Raven;\n    },\n\n    /*\n     * Wrap code within a context so Raven can capture errors\n     * reliably across domains that is executed immediately.\n     *\n     * @param {object} options A specific set of options for this context [optional]\n     * @param {function} func The callback to be immediately executed within the context\n     * @param {array} args An array of arguments to be called with the callback [optional]\n     */\n    context: function(options, func, args) {\n        if (isFunction(options)) {\n            args = func || [];\n            func = options;\n            options = undefined;\n        }\n\n        return Raven.wrap(options, func).apply(this, args);\n    },\n\n    /*\n     * Wrap code within a context and returns back a new function to be executed\n     *\n     * @param {object} options A specific set of options for this context [optional]\n     * @param {function} func The function to be wrapped in a new context\n     * @return {function} The newly wrapped functions with a context\n     */\n    wrap: function(options, func) {\n        // 1 argument has been passed, and it's not a function\n        // so just return it\n        if (isUndefined(func) && !isFunction(options)) {\n            return options;\n        }\n\n        // options is optional\n        if (isFunction(options)) {\n            func = options;\n            options = undefined;\n        }\n\n        // At this point, we've passed along 2 arguments, and the second one\n        // is not a function either, so we'll just return the second argument.\n        if (!isFunction(func)) {\n            return func;\n        }\n\n        // We don't wanna wrap it twice!\n        if (func.__raven__) {\n            return func;\n        }\n\n        function wrapped() {\n            var args = [], i = arguments.length,\n                deep = !options || options && options.deep !== false;\n            // Recursively wrap all of a function's arguments that are\n            // functions themselves.\n\n            while(i--) args[i] = deep ? Raven.wrap(options, arguments[i]) : arguments[i];\n\n            try {\n                /*jshint -W040*/\n                return func.apply(this, args);\n            } catch(e) {\n                Raven.captureException(e, options);\n                throw e;\n            }\n        }\n\n        // copy over properties of the old function\n        for (var property in func) {\n            if (hasKey(func, property)) {\n                wrapped[property] = func[property];\n            }\n        }\n\n        // Signal that this function has been wrapped already\n        // for both debugging and to prevent it to being wrapped twice\n        wrapped.__raven__ = true;\n        wrapped.__inner__ = func;\n\n        return wrapped;\n    },\n\n    /*\n     * Uninstalls the global error handler.\n     *\n     * @return {Raven}\n     */\n    uninstall: function() {\n        TraceKit.report.uninstall();\n        isRavenInstalled = false;\n\n        return Raven;\n    },\n\n    /*\n     * Manually capture an exception and send it over to Sentry\n     *\n     * @param {error} ex An exception to be logged\n     * @param {object} options A specific set of options for this error [optional]\n     * @return {Raven}\n     */\n    captureException: function(ex, options) {\n        // If not an Error is passed through, recall as a message instead\n        if (!isError(ex)) return Raven.captureMessage(ex, options);\n\n        // Store the raw exception object for potential debugging and introspection\n        lastCapturedException = ex;\n\n        // TraceKit.report will re-raise any exception passed to it,\n        // which means you have to wrap it in try/catch. Instead, we\n        // can wrap it here and only re-raise if TraceKit.report\n        // raises an exception different from the one we asked to\n        // report on.\n        try {\n            TraceKit.report(ex, options);\n        } catch(ex1) {\n            if(ex !== ex1) {\n                throw ex1;\n            }\n        }\n\n        return Raven;\n    },\n\n    /*\n     * Manually send a message to Sentry\n     *\n     * @param {string} msg A plain message to be captured in Sentry\n     * @param {object} options A specific set of options for this message [optional]\n     * @return {Raven}\n     */\n    captureMessage: function(msg, options) {\n        // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an\n        // early call; we'll error on the side of logging anything called before configuration since it's\n        // probably something you should see:\n        if (!!globalOptions.ignoreErrors.test && globalOptions.ignoreErrors.test(msg)) {\n            return;\n        }\n\n        // Fire away!\n        send(\n            objectMerge({\n                message: msg + ''  // Make sure it's actually a string\n            }, options)\n        );\n\n        return Raven;\n    },\n\n    /*\n     * Set/clear a user to be sent along with the payload.\n     *\n     * @param {object} user An object representing user data [optional]\n     * @return {Raven}\n     */\n    setUserContext: function(user) {\n        globalUser = user;\n\n        return Raven;\n    },\n\n    /*\n     * Set extra attributes to be sent along with the payload.\n     *\n     * @param {object} extra An object representing extra data [optional]\n     * @return {Raven}\n     */\n    setExtraContext: function(extra) {\n        globalOptions.extra = extra || {};\n\n        return Raven;\n    },\n\n    /*\n     * Set tags to be sent along with the payload.\n     *\n     * @param {object} tags An object representing tags [optional]\n     * @return {Raven}\n     */\n    setTagsContext: function(tags) {\n        globalOptions.tags = tags || {};\n\n        return Raven;\n    },\n\n    /*\n     * Set release version of application\n     *\n     * @param {string} release Typically something like a git SHA to identify version\n     * @return {Raven}\n     */\n    setReleaseContext: function(release) {\n        globalOptions.release = release;\n\n        return Raven;\n    },\n\n    /*\n     * Get the latest raw exception that was captured by Raven.\n     *\n     * @return {error}\n     */\n    lastException: function() {\n        return lastCapturedException;\n    },\n\n    /*\n     * Get the last event id\n     *\n     * @return {string}\n     */\n    lastEventId: function() {\n        return lastEventId;\n    },\n\n    /*\n     * Determine if Raven is setup and ready to go.\n     *\n     * @return {boolean}\n     */\n    isSetup: function() {\n        return isSetup();\n    }\n};\n\nRaven.setUser = Raven.setUserContext; // To be deprecated\n\nfunction triggerEvent(eventType, options) {\n    var event, key;\n\n    options = options || {};\n\n    eventType = 'raven' + eventType.substr(0,1).toUpperCase() + eventType.substr(1);\n\n    if (document.createEvent) {\n        event = document.createEvent('HTMLEvents');\n        event.initEvent(eventType, true, true);\n    } else {\n        event = document.createEventObject();\n        event.eventType = eventType;\n    }\n\n    for (key in options) if (hasKey(options, key)) {\n        event[key] = options[key];\n    }\n\n    if (document.createEvent) {\n        // IE9 if standards\n        document.dispatchEvent(event);\n    } else {\n        // IE8 regardless of Quirks or Standards\n        // IE9 if quirks\n        try {\n            document.fireEvent('on' + event.eventType.toLowerCase(), event);\n        } catch(e) {}\n    }\n}\n\nvar dsnKeys = 'source protocol user pass host port path'.split(' '),\n    dsnPattern = /^(?:(\\w+):)?\\/\\/(\\w+)(:\\w+)?@([\\w\\.-]+)(?::(\\d+))?(\\/.*)/;\n\nfunction RavenConfigError(message) {\n    this.name = 'RavenConfigError';\n    this.message = message;\n}\nRavenConfigError.prototype = new Error();\nRavenConfigError.prototype.constructor = RavenConfigError;\n\n/**** Private functions ****/\nfunction parseDSN(str) {\n    var m = dsnPattern.exec(str),\n        dsn = {},\n        i = 7;\n\n    try {\n        while (i--) dsn[dsnKeys[i]] = m[i] || '';\n    } catch(e) {\n        throw new RavenConfigError('Invalid DSN: ' + str);\n    }\n\n    if (dsn.pass)\n        throw new RavenConfigError('Do not specify your private key in the DSN!');\n\n    return dsn;\n}\n\nfunction isUndefined(what) {\n    return typeof what === 'undefined';\n}\n\nfunction isFunction(what) {\n    return typeof what === 'function';\n}\n\nfunction isString(what) {\n    return typeof what === 'string';\n}\n\nfunction isObject(what) {\n    return typeof what === 'object' && what !== null;\n}\n\nfunction isEmptyObject(what) {\n    for (var k in what) return false;\n    return true;\n}\n\n// Sorta yanked from https://github.com/joyent/node/blob/aa3b4b4/lib/util.js#L560\n// with some tiny modifications\nfunction isError(what) {\n    return isObject(what) &&\n        objectPrototype.toString.call(what) === '[object Error]' ||\n        what instanceof Error;\n}\n\n/**\n * hasKey, a better form of hasOwnProperty\n * Example: hasKey(MainHostObject, property) === true/false\n *\n * @param {Object} host object to check property\n * @param {string} key to check\n */\nfunction hasKey(object, key) {\n    return objectPrototype.hasOwnProperty.call(object, key);\n}\n\nfunction each(obj, callback) {\n    var i, j;\n\n    if (isUndefined(obj.length)) {\n        for (i in obj) {\n            if (hasKey(obj, i)) {\n                callback.call(null, i, obj[i]);\n            }\n        }\n    } else {\n        j = obj.length;\n        if (j) {\n            for (i = 0; i < j; i++) {\n                callback.call(null, i, obj[i]);\n            }\n        }\n    }\n}\n\n\nfunction setAuthQueryString() {\n    authQueryString =\n        '?sentry_version=4' +\n        '&sentry_client=raven-js/' + Raven.VERSION +\n        '&sentry_key=' + globalKey;\n}\n\n\nfunction handleStackInfo(stackInfo, options) {\n    var frames = [];\n\n    if (stackInfo.stack && stackInfo.stack.length) {\n        each(stackInfo.stack, function(i, stack) {\n            var frame = normalizeFrame(stack);\n            if (frame) {\n                frames.push(frame);\n            }\n        });\n    }\n\n    triggerEvent('handle', {\n        stackInfo: stackInfo,\n        options: options\n    });\n\n    processException(\n        stackInfo.name,\n        stackInfo.message,\n        stackInfo.url,\n        stackInfo.lineno,\n        frames,\n        options\n    );\n}\n\nfunction normalizeFrame(frame) {\n    if (!frame.url) return;\n\n    // normalize the frames data\n    var normalized = {\n        filename:   frame.url,\n        lineno:     frame.line,\n        colno:      frame.column,\n        'function': frame.func || '?'\n    }, context = extractContextFromFrame(frame), i;\n\n    if (context) {\n        var keys = ['pre_context', 'context_line', 'post_context'];\n        i = 3;\n        while (i--) normalized[keys[i]] = context[i];\n    }\n\n    normalized.in_app = !( // determine if an exception came from outside of our app\n        // first we check the global includePaths list.\n        !globalOptions.includePaths.test(normalized.filename) ||\n        // Now we check for fun, if the function name is Raven or TraceKit\n        /(Raven|TraceKit)\\./.test(normalized['function']) ||\n        // finally, we do a last ditch effort and check for raven.min.js\n        /raven\\.(min\\.)?js$/.test(normalized.filename)\n    );\n\n    return normalized;\n}\n\nfunction extractContextFromFrame(frame) {\n    // immediately check if we should even attempt to parse a context\n    if (!frame.context || !globalOptions.fetchContext) return;\n\n    var context = frame.context,\n        pivot = ~~(context.length / 2),\n        i = context.length, isMinified = false;\n\n    while (i--) {\n        // We're making a guess to see if the source is minified or not.\n        // To do that, we make the assumption if *any* of the lines passed\n        // in are greater than 300 characters long, we bail.\n        // Sentry will see that there isn't a context\n        if (context[i].length > 300) {\n            isMinified = true;\n            break;\n        }\n    }\n\n    if (isMinified) {\n        // The source is minified and we don't know which column. Fuck it.\n        if (isUndefined(frame.column)) return;\n\n        // If the source is minified and has a frame column\n        // we take a chunk of the offending line to hopefully shed some light\n        return [\n            [],  // no pre_context\n            context[pivot].substr(frame.column, 50), // grab 50 characters, starting at the offending column\n            []   // no post_context\n        ];\n    }\n\n    return [\n        context.slice(0, pivot),    // pre_context\n        context[pivot],             // context_line\n        context.slice(pivot + 1)    // post_context\n    ];\n}\n\nfunction processException(type, message, fileurl, lineno, frames, options) {\n    var stacktrace, label, i;\n\n    // In some instances message is not actually a string, no idea why,\n    // so we want to always coerce it to one.\n    message += '';\n\n    // Sometimes an exception is getting logged in Sentry as\n    // <no message value>\n    // This can only mean that the message was falsey since this value\n    // is hardcoded into Sentry itself.\n    // At this point, if the message is falsey, we bail since it's useless\n    if (type === 'Error' && !message) return;\n\n    if (globalOptions.ignoreErrors.test(message)) return;\n\n    if (frames && frames.length) {\n        fileurl = frames[0].filename || fileurl;\n        // Sentry expects frames oldest to newest\n        // and JS sends them as newest to oldest\n        frames.reverse();\n        stacktrace = {frames: frames};\n    } else if (fileurl) {\n        stacktrace = {\n            frames: [{\n                filename: fileurl,\n                lineno: lineno,\n                in_app: true\n            }]\n        };\n    }\n\n    // Truncate the message to a max of characters\n    message = truncate(message, globalOptions.maxMessageLength);\n\n    if (globalOptions.ignoreUrls && globalOptions.ignoreUrls.test(fileurl)) return;\n    if (globalOptions.whitelistUrls && !globalOptions.whitelistUrls.test(fileurl)) return;\n\n    label = lineno ? message + ' at ' + lineno : message;\n\n    // Fire away!\n    send(\n        objectMerge({\n            // sentry.interfaces.Exception\n            exception: {\n                type: type,\n                value: message\n            },\n            // sentry.interfaces.Stacktrace\n            stacktrace: stacktrace,\n            culprit: fileurl,\n            message: label\n        }, options)\n    );\n}\n\nfunction objectMerge(obj1, obj2) {\n    if (!obj2) {\n        return obj1;\n    }\n    each(obj2, function(key, value){\n        obj1[key] = value;\n    });\n    return obj1;\n}\n\nfunction truncate(str, max) {\n    return str.length <= max ? str : str.substr(0, max) + '\\u2026';\n}\n\nfunction now() {\n    return +new Date();\n}\n\nfunction getHttpData() {\n    var http = {\n        url: document.location.href,\n        headers: {\n            'User-Agent': navigator.userAgent\n        }\n    };\n\n    if (document.referrer) {\n        http.headers.Referer = document.referrer;\n    }\n\n    return http;\n}\n\nfunction send(data) {\n    if (!isSetup()) return;\n\n    data = objectMerge({\n        project: globalProject,\n        logger: globalOptions.logger,\n        platform: 'javascript',\n        // sentry.interfaces.Http\n        request: getHttpData()\n    }, data);\n\n    // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge\n    data.tags = objectMerge(objectMerge({}, globalOptions.tags), data.tags);\n    data.extra = objectMerge(objectMerge({}, globalOptions.extra), data.extra);\n\n    // Send along our own collected metadata with extra\n    data.extra = objectMerge({\n        'session:duration': now() - startTime\n    }, data.extra);\n\n    // If there are no tags/extra, strip the key from the payload alltogther.\n    if (isEmptyObject(data.tags)) delete data.tags;\n\n    if (globalUser) {\n        // sentry.interfaces.User\n        data.user = globalUser;\n    }\n\n    // Include the release iff it's defined in globalOptions\n    if (globalOptions.release) data.release = globalOptions.release;\n\n    if (isFunction(globalOptions.dataCallback)) {\n        data = globalOptions.dataCallback(data);\n    }\n\n    // Check if the request should be filtered or not\n    if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {\n        return;\n    }\n\n    // Send along an event_id if not explicitly passed.\n    // This event_id can be used to reference the error within Sentry itself.\n    // Set lastEventId after we know the error should actually be sent\n    lastEventId = data.event_id || (data.event_id = uuid4());\n\n    makeRequest(data);\n}\n\n\nfunction makeRequest(data) {\n    var img = new Image(),\n        src = globalServer + authQueryString + '&sentry_data=' + encodeURIComponent(JSON.stringify(data));\n\n    img.crossOrigin = 'anonymous';\n    img.onload = function success() {\n        triggerEvent('success', {\n            data: data,\n            src: src\n        });\n    };\n    img.onerror = img.onabort = function failure() {\n        triggerEvent('failure', {\n            data: data,\n            src: src\n        });\n    };\n    img.src = src;\n}\n\nfunction isSetup() {\n    if (!hasJSON) return false;  // needs JSON support\n    if (!globalServer) {\n        logDebug('error', 'Error: Raven has not been configured.');\n        return false;\n    }\n    return true;\n}\n\nfunction joinRegExp(patterns) {\n    // Combine an array of regular expressions and strings into one large regexp\n    // Be mad.\n    var sources = [],\n        i = 0, len = patterns.length,\n        pattern;\n\n    for (; i < len; i++) {\n        pattern = patterns[i];\n        if (isString(pattern)) {\n            // If it's a string, we need to escape it\n            // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n            sources.push(pattern.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"));\n        } else if (pattern && pattern.source) {\n            // If it's a regexp already, we want to extract the source\n            sources.push(pattern.source);\n        }\n        // Intentionally skip other cases\n    }\n    return new RegExp(sources.join('|'), 'i');\n}\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\nfunction uuid4() {\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0,\n            v = c == 'x' ? r : (r&0x3|0x8);\n        return v.toString(16);\n    });\n}\n\nfunction logDebug(level, message) {\n    if (window.console && console[level] && Raven.debug) {\n        console[level](message);\n    }\n}\n\nfunction afterLoad() {\n    // Attempt to initialize Raven on load\n    var RavenConfig = window.RavenConfig;\n    if (RavenConfig) {\n        Raven.config(RavenConfig.dsn, RavenConfig.config).install();\n    }\n}\nafterLoad();\n\n// Expose Raven to the world\nif (typeof define === 'function' && define.amd) {\n    // AMD\n    window.Raven = Raven;\n    define('raven', [], function() {\n      return Raven;\n    });\n} else if (typeof module === 'object') {\n    // browserify\n    module.exports = Raven;\n} else if (typeof exports === 'object') {\n    // CommonJS\n    exports = Raven;\n} else {\n    // Everything else\n    window.Raven = Raven;\n}\n\n})(window);\n\n","define('modules/monitor',[\n    'raven'\n], function (\n    Raven\n) {\n\n\tvar config = {\n\t\tdsn: null,\n\t\tgit_commit: 'not available'\n\t};\t\t\n\t\n\ttry {\n\t\tconfig = {\n\t\t\tdsn: GRUNT_SENTRY_DSN,\n\t\t\tgit_commit: GRUNT_LAST_GIT_COMMIT\n\t\t};   \n\t} catch(e) {}\n\n\tvar modules = {\n\t\textractTags: function() {\n\t\t\tvar bodyClass = document.body.getAttribute('class');\n\t\t\tvar itemTone = bodyClass.match(/tone--([^\\s]+)/); \n\n\t\t\treturn {\n\t\t\t\titemTone: itemTone ? itemTone[1] : null,\n\t\t\t\titemId: document.body.getAttribute('data-page-id'),\n\t\t\t\tdeviceKind: document.body.getAttribute('data-ads-config'),\n\t\t\t\tads: document.body.getAttribute('data-ads-enabled') === 'true',\n\t\t\t};\n\t\t},\n\t\tignoreErrors: function() {\n\t\t\tvar ignoreArray = ['fake'];\n\t\t\tignoreArray.push = function(){};\n\t\t\treturn ignoreArray;\n\t\t},\n\t\tsetContext: function(context, fn){\n\t\t\tif(config.dsn){\n\t\t\t\treturn Raven.context({ tags: { context: context }}, fn);\n\t\t\t}\n\t\t\treturn fn();\n\t\t}\n\t};\n\n\tvar init = function(){\n\t\tvar tags = modules.extractTags();\n\t\tif(!Raven.isSetup() && config.dsn){\n\t\t\tRaven.config(config.dsn, { \n\t\t\t\ttags: tags,\n\t\t\t\trelease: config.git_commit,\n\t\t\t\tignoreErrors: modules.ignoreErrors(),\n\t\t\t\tshouldSendCallback: function(data) {\n\t\t\t\t\tif(data.stacktrace && data.stacktrace.frames){\n\t\t\t\t\t\tdata.stacktrace.frames = data.stacktrace.frames.reverse().slice(0,3).reverse();\n\t\t\t\t\t}\n\t\t\t\t\tvar sampleRate = 35;\n\t\t\t\t\treturn (Math.random() * 100 <= sampleRate);\n\t\t\t\t}\t\t\t\t\n\t\t\t}).install();\n\t\t}\n\t};\n\n    return {\n    \tinit: init,\n    \tsetContext: modules.setContext,\n    \tmodules: modules,\n    \tconfig: config,\n        raven: Raven\n    };\n});\n\n"]}